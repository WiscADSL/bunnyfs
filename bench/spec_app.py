"""
This file generates the app specifications for experiments.
"""
import dataclasses

from exp_leveldb_prep import get_prep_dbs
from spec import *
from typing import List, Tuple, Optional, Union
from prep_files import get_prep_files
from dataclasses import dataclass


@dataclass(frozen=True)
class WorkloadConfigPerApp:
    """
    A high-level description of a static workload of an app.
    The fields below are used to generate a Workload object and should be filled manually.
    """
    offset_type: OffsetType
    working_set_gb: float
    duration_sec: int
    read_ratio: float
    qdepth: int
    count: int
    zipf_theta: Optional[float] = None

    def __post_init__(self):
        if self.offset_type == OffsetType.ZIPF:
            assert self.zipf_theta is not None, (
                "zipf_theta must be set for offset_type ZIPF"
            )
        else:
            assert self.zipf_theta is None, (
                f"zipf_theta must be None for offset_type {self.offset_type}"
            )

    def get_workload(self, tid: int, num_threads: int, num_files: int):
        ws = int(self.working_set_gb * 1024 * 1024 * 1024)
        ws_per_file = ws // num_files

        return Workload(
            name=self.name,
            offset=Offset(
                type=self.offset_type,
                min=0,
                max=ws_per_file // self.count * self.count,
                align=self.count,
                theta=self.zipf_theta if self.offset_type == OffsetType.ZIPF else 0.0,
            ),
            qdepth=self.qdepth,
            count=self.count,
            duration_sec=self.duration_sec,
            read_ratio=self.read_ratio,
        )

    @property
    def name(self):
        return (
            f"{self.offset_type.short_name()}{self.working_set_gb:g}G"
            f"{f'{self.zipf_theta * 100:.0f}' if self.offset_type == OffsetType.ZIPF else ''}"
            f"{f'-R{self.read_ratio * 100:.0f}' if self.read_ratio != 1.0 else ''}"
        )

    @property
    def desc(self):
        return (
            f"{self.offset_type.capitalize()}"
            f"{f' (zipf_theta={self.zipf_theta})' if self.offset_type == OffsetType.ZIPF else ''}"
            f" {self.read_ratio * 100:.0f}% read"
            f" with {self.working_set_gb} GB working set "
        )


@dataclass(frozen=True)
class _AppConfig:
    """
    A high-level configuration of an app used to generate an App object or a Thread object.
    This config should not be manually created, but rather generated by ExpConfig to avoid
    inconsistency.
    """
    aid: int
    thread_type: ThreadType
    num_threads: int
    num_workers: int
    start_worker_id: int
    core_ids: List[int]
    use_affinity: bool
    file_paths_per_app: List[str]
    db_paths_per_app: List[str]
    name: Optional[str] = None

    def __post_init__(self):
        # a file should be exclusively owned by a thread
        assert self.num_files_total % self.num_threads == 0

    @property
    def num_files_total(self):
        return len(self.file_paths_per_app)

    # `pt` for "per thread"; `ptw` for "per (thread, worker) pair"
    @property
    def num_files_pt(self):
        return self.num_files_total // self.num_threads

    def _get_file_paths(self, tid: int):
        return self.file_paths_per_app[tid * self.num_files_pt: (tid + 1) * self.num_files_pt]

    def _get_name(self, workload_configs: List[WorkloadConfigPerApp]):
        if self.name is not None:
            return self.name
        return f"{'|'.join([c.name for c in workload_configs])}"

    def _get_thread(
            self,
            tid: int,
            workload_configs: List[WorkloadConfigPerApp],
    ):
        assert len(workload_configs) > 0
        file_paths = self._get_file_paths(tid)

        if self.use_affinity:
            assert self.num_threads % self.num_workers == 0
            num_threads_pw = self.num_threads // self.num_workers

            worker_id = self.start_worker_id + tid // num_threads_pw
            pin_file_map = {}
        else:
            assert self.num_files_pt % self.num_workers == 0
            num_files_ptw = self.num_files_pt // self.num_workers

            worker_id = -1
            pin_file_map = {
                file_paths[i]: self.start_worker_id + (i // num_files_ptw)
                for i in range(self.num_files_pt)
            }

        return Thread(
            name=f"{self._get_name(workload_configs)}-T{tid}",
            type=self.thread_type,
            file_paths=file_paths,
            db_path=self.db_paths_per_app[tid] if self.thread_type == ThreadType.DB else "",
            core=self.core_ids[tid],
            worker_id=worker_id,
            workloads=[
                c.get_workload(
                    tid,
                    num_threads=self.num_threads,
                    num_files=self.num_files_total,
                )
                for c in workload_configs
            ],
            pin_file_map=pin_file_map
        )

    def get_app(
            self,
            workload_configs: Union[List[WorkloadConfigPerApp], WorkloadConfigPerApp],
    ):
        if isinstance(workload_configs, WorkloadConfigPerApp):
            workload_configs = [workload_configs]

        return App(
            name=self._get_name(workload_configs),
            desc=(
                f"{', '.join([c.desc for c in workload_configs])}"
                f"[policy: use_affinity={self.use_affinity}]"
            ),
            aid=self.aid,
            threads=[
                self._get_thread(
                    tid=tid,
                    workload_configs=workload_configs,
                )
                for tid in range(self.num_threads)
            ],
        )


@dataclass()
class ExpConfig:
    num_workers: int
    num_apps: int
    num_threads_per_app: int
    num_files_per_app: int
    use_affinity: bool
    is_symm: bool
    thread_type: ThreadType = ThreadType.RW

    # derived fields, do not appear in __init__
    files: List[PrepFile] = dataclasses.field(init=False)
    file_paths: List[str] = dataclasses.field(init=False)
    db_paths: List[str] = dataclasses.field(init=False)

    def __post_init__(self):
        if self.thread_type == ThreadType.RW:
            assert self.num_files_per_app >= self.num_threads_per_app, (
                "for each app, num_files must be larger than num_threads "
                "so that every thread has at least one file"
            )

        assert self.is_symm or self.num_workers % self.num_apps == 0

        self.files = get_prep_files(
            num_files=self.num_files_per_app * self.num_apps)
        self.file_paths = [f.path for f in self.files]
        self.db_paths = [db.path for db in get_prep_dbs()]
        assert len(self.db_paths) >= self.num_apps * self.num_threads_per_app

    @property
    def num_workers_per_app(self):
        return self.num_workers if self.is_symm else self.num_workers // self.num_apps

    def _get_start_worker_id(self, aid: int):
        return 0 if self.is_symm else aid * self.num_workers // self.num_apps

    def _get_file_paths(self, aid: int):
        assert aid < self.num_apps
        if self.thread_type != ThreadType.RW:
            return []

        return self.file_paths[aid * self.num_files_per_app:
                               (aid + 1) * self.num_files_per_app]

    def _get_db_paths(self, aid: int):
        assert aid < self.num_apps
        if self.thread_type != ThreadType.DB:
            return []

        return self.db_paths[aid * self.num_threads_per_app:
                             (aid + 1) * self.num_threads_per_app]

    def _get_core_ids(self, aid: int):
        assert aid < self.num_apps
        start_core_id = aid * self.num_threads_per_app + 1  # 1-based index
        return list(range(start_core_id, start_core_id + self.num_threads_per_app))

    def get_app(self, aid: int, name: str, workload_configs: Union[List[WorkloadConfigPerApp], WorkloadConfigPerApp]):
        assert aid < self.num_apps
        if not isinstance(workload_configs, list):
            workload_configs = [workload_configs]
        return _AppConfig(
            aid=aid,
            name=name,
            thread_type=self.thread_type,
            num_threads=self.num_threads_per_app,
            num_workers=self.num_workers_per_app,
            start_worker_id=self._get_start_worker_id(aid),
            core_ids=self._get_core_ids(aid),
            use_affinity=self.use_affinity,
            file_paths_per_app=self._get_file_paths(aid),
            db_paths_per_app=self._get_db_paths(aid),
        ).get_app(workload_configs=workload_configs)

    def get_exp(self, apps: List[App]):
        assert len(apps) == self.num_apps
        return Exp(
            num_workers=self.num_workers,
            prep=Prep(),
            apps=apps,
        )


def export_spec(
        *,
        exp_name,
        # each app -> (offset_type, working_set_gb, read_ratio, zipf_theta,  name)
        app_configs: List[Tuple[OffsetType, float, float, Optional[float], Optional[str]]],
        total_num_workers: int,
        num_threads_per_app: int,
        num_files_per_app: int,
        qdepth: int,
        # if use_affinity, each app thread will only access one worker (else every
        # thread will access every worker)
        use_affinity: bool,
        # if is_symm, every app's load will be evenly spread across all workers;
        # otherwise, every app will get dedicated (non-shared) workers
        is_symm: bool = True,
        duration_sec: int = 36,
):
    exp_config = ExpConfig(
        num_workers=total_num_workers,
        num_apps=len(app_configs),
        num_threads_per_app=num_threads_per_app,
        num_files_per_app=num_files_per_app,
        use_affinity=use_affinity,
        is_symm=is_symm,
    )

    apps = [
        exp_config.get_app(aid, name, WorkloadConfigPerApp(
            offset_type=offset_type,
            working_set_gb=working_set_gb,
            read_ratio=read_ratio,
            zipf_theta=zipf_theta,
            qdepth=qdepth,
            duration_sec=duration_sec,
            count=16384,  # each op will read 16KB data
        ))
        for (aid, (offset_type, working_set_gb, read_ratio, zipf_theta, name))
        in enumerate(app_configs)
    ]

    return exp_config.get_exp(apps).export_with_name(exp_name)
